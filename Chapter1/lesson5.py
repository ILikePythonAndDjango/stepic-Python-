# -*- coding: utf-8 -*-
# lesson 1.5: Introduction to Classes

# MoneyBox

'''
class MoneyBox:

	def __init__(self, capacity):
		"""Конструктр с аргументов - вместимости копилки"""
		self.capacity = capacity
		self.quantity = 0

	def can_add(self, v):
		"""True, если можно добавить v монет, иначе False"""
		if v <= (self.capacity - self.quantity):
			return True
		else:
			return False

	def add(self, v):
		"""положить v монет в копилку"""
		if self.can_add(v):
			self.quantity += v

qiwi = MoneyBox(500)
print(qiwi.quantity)
qiwi.add(300)
print(qiwi.quantity)
qiwi.add(300)
print(qiwi.quantity)
'''

# Обработка последовательности чисел
'''
Есть некая последовательность чисел и ее нужно обработать,
вывести на экран сумму первой пятерки чисел из этой последовательности,
затем сумму второй пятерки, и т. д.

Последовательлность не дается сразу целеком.

Нужно реализовать класс, который будет делать выше перечисленные манипуляции, а
так же он не должен хранить элементов в себе больше, чем ему необходимо,
т. е. он должен хранить элементы, которые уже вошли в пятерку, для которой была выведена сумма.

Во время выполнения метода add выводить сумму пятерок можетпотребоваться несколько раз до тех
пор, пока в буфере не останеться менее пяти элементов.

Реализуем класс Buffer. Она будет содержать конструктор и два метода: add(), get_current_part().
Возможно в конструкторе будут находиться аргументы, но это не факт.
В методе add будут два аргумента.Первый аргумент будет принимать объект, а второй будет принимать последовательност цифр в списке.
В теле это метода будет цикл, который переберет этот список и каждый элемент добавит к списку buffer.
Затем он проверит сколько элементов находятся в списке buffer. Если их больше или равно пяти, то он выведет их сумму в консоль,
а если нет, то он ничего делатьне будет.
'''

class Buffer:
	
	def __init__(self):
		"""конструктор без аргументов"""
		self.buffer = list()

	def add(self, *a):
		"""добавить следующую часть последовательности"""
		self.buffer.extend(a)
		while len(self.buffer) >= 5:
			print(sum(self.buffer[0:5]))
			del self.buffer[0:5]
		
	def get_current_part(self):
		"""вернуть сохраненные в текущий момент элементы последовательности в порядке, в котором они были добавлены"""
		return self.buffer

buf = Buffer()
buf.add(1, 2, 3)
print(buf.get_current_part()) # вернуть [1, 2, 3]
buf.add(4, 5, 6) # print(15) – вывод суммы первой пятерки элементов
print(buf.get_current_part()) # вернуть [6]
buf.add(7, 8, 9, 10) # print(40) – вывод суммы второй пятерки элементов
print(buf.get_current_part()) # вернуть []
buf.add(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) # print(5), print(5) – вывод сумм третьей и четвертой пятерки
print(buf.get_current_part()) # вернуть [1]